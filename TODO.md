Production-Ready API System
Assignment Overview

In this assignment, you will build a comprehensive, production-ready API system that demonstrates the patterns covered in W12D2. This is not just an exercise, it represents the kind of API architecture you would deploy in a real company environment. You will design, implement, secure, and deploy an API that can handle real-world traffic while following industry best practices.

You may choose any domain for your API (e.g., task management, inventory system, booking platform, social media, e-commerce, etc.). The key requirement is that your implementation demonstrates mastery of all the advanced API patterns taught in class.
Learning Objectives

Upon completing this assignment, you will be able to:

    Design and implement RESTful APIs following industry best practices with proper HTTP methods, status codes, and resource naming. 
    Implement JWT-based authentication with secure password handling and role-based access control. 
    Build rate limiting mechanisms using Redis to protect API resources. 
    Create robust error handling systems with standardized responses and comprehensive logging. 
    Implement asynchronous API calls for improved performance. 
    Deploy APIs with proper configuration, health checks, and monitoring.

Assignment Requirements
Part 1: RESTful API Design

Build a complete RESTful API for your chosen resource with the following requirements:

    Complete CRUD operations (Create, Read, Update, Delete) for at least one primary resource
    Proper HTTP methods: GET for retrieval, POST for creation, PUT/PATCH for updates, DELETE for removal
    Appropriate HTTP status codes: 200 OK, 201 Created, 204 No Content, 400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found, 429 Too Many Requests, 500 Internal Server Error
    Resource-based URL structure following REST conventions (nouns, not verbs)
    Pagination support for list endpoints with skip/limit or page/size parameters
    Filtering and sorting capabilities on collection endpoints

Part 2: Authentication & Security

Implement enterprise-grade security for your API:

    User registration endpoint with password hashing using bcrypt
    Login endpoint that returns JWT access tokens
    JWT token validation middleware for protected endpoints
    Role-based access control (RBAC) with at least two roles (e.g., user and admin)
    Input validation using Pydantic models with appropriate validators
    CORS configuration for cross-origin requests
    Secure password requirements (minimum length, complexity)

Part 3: Rate Limiting & Performance

Implement performance optimization and protection mechanisms:

    Rate limiting using Redis with sliding window or token bucket algorithm
    Rate limit headers in responses: X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset
    Appropriate 429 Too Many Requests responses with retry-after information
    At least one async endpoint using httpx for external API calls
    Background task processing using FastAPI BackgroundTasks
    Response caching strategy (can use Redis or in-memory caching)

Part 4: Production Patterns 

Implement production-ready patterns and observability:

    Custom exception classes with standardized error response format
    Global exception handlers for consistent error responses
    Request ID tracking via middleware (X-Request-ID header)
    Structured logging for all API requests and responses
    Health check endpoint (/health) for load balancer integration
    Detailed health check endpoint (/health/detailed) showing dependency status
    API versioning strategy implemented (URL-based recommended: /v1/, /v2/)

Part 5: Testing & Documentation

Ensure quality through testing and documentation:

    Unit tests for business logic using pytest
    Integration tests for API endpoints using TestClient
    Minimum 80% test coverage (use pytest-cov to measure)
    API documentation via OpenAPI/Swagger (automatically generated by FastAPI)
    Dockerfile for containerized deployment
    docker-compose.yml for local development with all dependencies (API, Redis, database)

Submission Requirements

Submit all of the following:

    GitHub Repository: Complete codebase with clear folder structure and .gitignore
    README.md: Comprehensive documentation including setup instructions, API documentation, environment variables, and architecture overview
    Demo Video (5 minutes): Screen recording demonstrating API functionality, authentication flow, rate limiting in action, and load testing results
    Live Deployment: Deploy to a cloud platform (Heroku, Railway, Render, or similar) and provide the live URL
    Postman Collection: Export and include a Postman collection with example requests for all endpoints

Success Criteria

Your API will be evaluated against these criteria:

    API handles 100+ concurrent requests without errors (demonstrate via load testing)
    Test coverage reaches 80% or higher
    Authentication flow works correctly with secure token management
    Rate limiting effectively prevents abuse and returns appropriate headers
    Error handling provides meaningful, consistent error messages
    Code follows Python best practices (PEP 8, type hints, docstrings)
    Deployment configuration is production-ready

Required Technical Stack

Your implementation should use the following technologies covered in class:

Framework
	

FastAPI >= 0.100.0

Server
	

Uvicorn

Authentication
	

PyJWT, passlib[bcrypt]

Rate Limiting
	

Redis

Async HTTP
	

httpx

Database (optional)
	

SQLite (development) or PostgreSQL

Testing
	

pytest, pytest-asyncio, pytest-cov
Resources

    Class materials from W12D2 (Canvas Module)
    FastAPI Documentation: https://fastapi.tiangolo.com 

Links to an external site.
JWT Introduction: https://jwt.io/introduction
Links to an external site.
Redis Documentation: https://redis.io/documentation
Links to an external site.
Instructor Resources: https://replit.com/@instructor/W12D2-Advanced-APIs
